import{a as De,c as Ie,f as W}from"./chunk-RW4GY4BD.js";var n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1};var q="app";var kt=Ie({});var At=Object.defineProperty,Et=(e,t)=>{for(var s in t)At(e,s,{get:t[s],enumerable:!0})},Ne={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting},Ke=n.hotModuleReplacement?window.__STENCIL_HOSTREFS__||(window.__STENCIL_HOSTREFS__=new WeakMap):new WeakMap,L=e=>Ke.get(e);var _t=(e,t)=>{let s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(o=>s.$onInstanceResolve$=o)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(o=>s.$onReadyResolve$=o),e["s-p"]=[],e["s-rc"]=[]),Ke.set(e,s)},Ce=(e,t)=>t in e,wt,C=(e,t)=>(wt||console.error)(e,t),Ye=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],K=(...e)=>console.error(...Ye,...e),F=(...e)=>console.warn(...Ye,...e);var ke=new Map;var Ut=(e,t,s)=>{let o=e.$tagName$.replace(/-/g,"_"),r=e.$lazyBundleId$;if(n.isDev&&typeof r!="string"){K(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}else if(!r)return;let i=n.hotModuleReplacement?!1:ke.get(r);if(i)return i[o];return kt(`./${r}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`).then(l=>(n.hotModuleReplacement||ke.set(r,l),l[o]),C)},Y=new Map,Ge=[],Rt="r",Ot="o",Bt="s",jt="t",le="s-id",Ae="sty-id",Ee="c-id";var Pt="slot-fb{display:contents}slot-fb[hidden]{display:none}",_e="http://www.w3.org/1999/xlink",zt=["formAssociatedCallback","formResetCallback","formDisabledCallback","formStateRestoreCallback"],P=typeof window<"u"?window:{},g=P.document||{head:{}},ln=P.HTMLElement||class{},p={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,o)=>e.addEventListener(t,s,o),rel:(e,t,s,o)=>e.removeEventListener(t,s,o),ce:(e,t)=>new CustomEvent(e,t)};var _=n.shadowDom,Mt=(()=>{let e=!1;try{g.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),Ft=e=>Promise.resolve(e),Ht=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,re=0,G=!1,Q=[],E=[],ie=[],Je=(e,t)=>s=>{e.push(s),G||(G=!0,t&&p.$flags$&4?ee(J):p.raf(J))},we=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){C(s)}e.length=0},Ue=(e,t)=>{let s=0,o=0;for(;s<e.length&&(o=performance.now())<t;)try{e[s++](o)}catch(r){C(r)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},J=()=>{if(n.asyncQueue&&re++,we(Q),n.asyncQueue){let e=(p.$flags$&6)===2?performance.now()+14*Math.ceil(re*.1):1/0;Ue(E,e),Ue(ie,e),E.length>0&&(ie.push(...E),E.length=0),(G=Q.length+E.length+ie.length>0)?p.raf(J):re=0}else we(E),(G=Q.length>0)&&p.raf(J)},ee=e=>Ft().then(e),cn=Je(Q,!1),Wt=Je(E,!0),dn=e=>{let t=new URL(e,p.$resourcesUrl$);return t.origin!==P.location.origin?t.href:t.pathname};var Re={},qt="http://www.w3.org/2000/svg",Xt="http://www.w3.org/1999/xhtml",Qt=e=>e!=null,ge=e=>(e=typeof e,e==="object"||e==="function");function Kt(e){var t,s,o;return(o=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?o:void 0}var Yt={};Et(Yt,{err:()=>Ze,map:()=>Gt,ok:()=>ce,unwrap:()=>Jt,unwrapErr:()=>Zt});var ce=e=>({isOk:!0,isErr:!1,value:e}),Ze=e=>({isOk:!1,isErr:!0,value:e});function Gt(e,t){if(e.isOk){let s=t(e.value);return s instanceof Promise?s.then(o=>ce(o)):ce(s)}if(e.isErr){let s=e.value;return Ze(s)}throw"should never get here"}var Jt=e=>{if(e.isOk)return e.value;throw e.value},Zt=e=>{if(e.isErr)return e.value;throw e.value},Vt=0,N=(e,t="")=>{if(n.profile&&performance.mark){let s=`st:${e}:${t}:${Vt++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},es=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{};var Ve=(e,t,...s)=>{let o=null,r=null,i=null,l=!1,c=!1,a=[],d=f=>{for(let u=0;u<f.length;u++)o=f[u],Array.isArray(o)?d(o):o!=null&&typeof o!="boolean"&&((l=typeof e!="function"&&!ge(o))?o=String(o):n.isDev&&typeof e!="function"&&o.$flags$===void 0&&K(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),l&&c?a[a.length-1].$text$+=o:a.push(l?B(null,o):o),c=l)};if(d(s),t&&(n.isDev&&e==="input"&&os(t),n.vdomKey&&t.key&&(r=t.key),n.slotRelocation&&t.name&&(i=t.name),n.vdomClass)){let f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(u=>f[u]).join(" "))}if(n.isDev&&a.some(de)&&K(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,a,ss);let $=B(e,null);return $.$attrs$=t,a.length>0&&($.$children$=a),n.vdomKey&&($.$key$=r),n.slotRelocation&&($.$name$=i),$},B=(e,t)=>{let s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},ts={},de=e=>e&&e.$tag$===ts,ss={forEach:(e,t)=>e.map(Oe).forEach(t),map:(e,t)=>e.map(Oe).map(t).map(ns)},Oe=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),ns=e=>{if(typeof e.vtag=="function"){let s=De({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),Ve(e.vtag,s,...e.vchildren||[])}let t=B(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},os=e=>{let t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;let o=t.indexOf("type"),r=t.indexOf("min"),i=t.indexOf("max"),l=t.indexOf("step");(s<o||s<r||s<i||s<l)&&F('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},rs=(e,t,s,o)=>{let r=N("hydrateClient",t),i=e.shadowRoot,l=[],c=[],a=n.shadowDom&&i?[]:null,d=o.$vnode$=B(t,null);p.$orgLocNodes$||fe(g.body,p.$orgLocNodes$=new Map),e[le]=s,e.removeAttribute(le),$e(d,l,c,a,e,e,s),l.map($=>{let f=$.$hostId$+"."+$.$nodeId$,u=p.$orgLocNodes$.get(f),h=$.$elm$;u&&_&&u["s-en"]===""&&u.parentNode.insertBefore(h,u.nextSibling),i||(h["s-hn"]=t,u&&(h["s-ol"]=u,h["s-ol"]["s-nr"]=h)),p.$orgLocNodes$.delete(f)}),n.shadowDom&&i&&a.map($=>{$&&i.appendChild($)}),r()},$e=(e,t,s,o,r,i,l)=>{let c,a,d,$;if(i.nodeType===1){if(c=i.getAttribute(Ee),c&&(a=c.split("."),(a[0]===l||a[0]==="0")&&(d={$flags$:0,$hostId$:a[0],$nodeId$:a[1],$depth$:a[2],$index$:a[3],$tag$:i.tagName.toLowerCase(),$elm$:i,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push(d),i.removeAttribute(Ee),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,e=d,o&&d.$depth$==="0"&&(o[d.$index$]=d.$elm$))),i.shadowRoot)for($=i.shadowRoot.childNodes.length-1;$>=0;$--)$e(e,t,s,o,r,i.shadowRoot.childNodes[$],l);for($=i.childNodes.length-1;$>=0;$--)$e(e,t,s,o,r,i.childNodes[$],l)}else if(i.nodeType===8)a=i.nodeValue.split("."),(a[1]===l||a[1]==="0")&&(c=a[0],d={$flags$:0,$hostId$:a[1],$nodeId$:a[2],$depth$:a[3],$index$:a[4],$elm$:i,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},c===jt?(d.$elm$=i.nextSibling,d.$elm$&&d.$elm$.nodeType===3&&(d.$text$=d.$elm$.textContent,t.push(d),i.remove(),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,o&&d.$depth$==="0"&&(o[d.$index$]=d.$elm$))):d.$hostId$===l&&(c===Bt?(d.$tag$="slot",a[5]?i["s-sn"]=d.$name$=a[5]:i["s-sn"]="",i["s-sr"]=!0,n.shadowDom&&o&&(d.$elm$=g.createElement(d.$tag$),d.$name$&&d.$elm$.setAttribute("name",d.$name$),i.parentNode.insertBefore(d.$elm$,i),i.remove(),d.$depth$==="0"&&(o[d.$index$]=d.$elm$)),s.push(d),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d):c===Rt&&(n.shadowDom&&o?i.remove():n.slotRelocation&&(r["s-cr"]=i,i["s-cn"]=!0))));else if(e&&e.$tag$==="style"){let f=B(null,i.textContent);f.$elm$=i,f.$index$="0",e.$children$=[f]}},fe=(e,t)=>{if(e.nodeType===1){let s=0;if(e.shadowRoot)for(;s<e.shadowRoot.childNodes.length;s++)fe(e.shadowRoot.childNodes[s],t);for(s=0;s<e.childNodes.length;s++)fe(e.childNodes[s],t)}else if(e.nodeType===8){let s=e.nodeValue.split(".");s[0]===Ot&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},is=e=>Ge.map(t=>t(e)).find(t=>!!t),et=e=>Ge.push(e),tt=e=>L(e).$modeName$,as=(e,t)=>e!=null&&!ge(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,ls=e=>n.lazyLoad?L(e).$hostElement$:e,xn=(e,t,s)=>{let o=ls(e);return{emit:r=>(n.isDev&&!o.isConnected&&F(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),ye(o,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:r}))}},ye=(e,t,s)=>{let o=p.ce(t,s);return e.dispatchEvent(o),o},Be=new WeakMap,cs=(e,t,s)=>{let o=Y.get(e);Ht&&s?(o=o||new CSSStyleSheet,typeof o=="string"?o=t:o.replaceSync(t)):o=t,Y.set(e,o)},ue=(e,t,s)=>{var o;let r=st(t,s),i=Y.get(r);if(!n.attachStyles)return r;if(e=e.nodeType===11?e:g,i)if(typeof i=="string"){e=e.head||e;let l=Be.get(e),c;if(l||Be.set(e,l=new Set),!l.has(r)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${Ae}="${r}"]`)))c.innerHTML=i;else{c=g.createElement("style"),c.innerHTML=i;let a=(o=p.$nonce$)!=null?o:Kt(g);a!=null&&c.setAttribute("nonce",a),(n.hydrateServerSide||n.hotModuleReplacement)&&t.$flags$&2&&c.setAttribute(Ae,r),(!(t.$flags$&1)||t.$flags$&1&&e.nodeName!=="HEAD")&&e.insertBefore(c,e.querySelector("link"))}t.$flags$&4&&(c.innerHTML+=Pt),l&&l.add(r)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(i)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,i]);return r},ds=e=>{let t=e.$cmpMeta$,s=e.$hostElement$,o=t.$flags$,r=N("attachStyles",t.$tagName$),i=ue(n.shadowDom&&_&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);(n.shadowDom||n.scoped)&&n.cssAnnotations&&o&10&&o&2&&(s["s-sc"]=i,s.classList.add(i+"-h"),n.scoped&&o&2&&s.classList.add(i+"-s")),r()},st=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),je=(e,t,s,o,r,i)=>{if(s!==o){let l=Ce(e,t),c=t.toLowerCase();if(n.vdomClass&&t==="class"){let a=e.classList,d=Pe(s),$=Pe(o);a.remove(...d.filter(f=>f&&!$.includes(f))),a.add(...$.filter(f=>f&&!d.includes(f)))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(let a in s)(!o||o[a]==null)&&(!n.hydrateServerSide&&a.includes("-")?e.style.removeProperty(a):e.style[a]="");for(let a in o)(!s||o[a]!==s[a])&&(!n.hydrateServerSide&&a.includes("-")?e.style.setProperty(a,o[a]):e.style[a]=o[a])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")o&&o(e);else if(n.vdomListener&&(n.lazyLoad?!l:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):Ce(P,c)?t=c.slice(2):t=c[2]+t.slice(3),s||o){let a=t.endsWith(nt);t=t.replace(fs,""),s&&p.rel(e,t,s,a),o&&p.ael(e,t,o,a)}}else if(n.vdomPropOrAttr){let a=ge(o);if((l||a&&o!==null)&&!r)try{if(e.tagName.includes("-"))e[t]=o;else{let $=o==null?"":o;t==="list"?l=!1:(s==null||e[t]!=$)&&(e[t]=$)}}catch{}let d=!1;n.vdomXlink&&c!==(c=c.replace(/^xlink\:?/,""))&&(t=c,d=!0),o==null||o===!1?(o!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&d?e.removeAttributeNS(_e,t):e.removeAttribute(t)):(!l||i&4||r)&&!a&&(o=o===!0?"":o,n.vdomXlink&&d?e.setAttributeNS(_e,t,o):e.setAttribute(t,o))}}}},$s=/\s/,Pe=e=>e?e.split($s):[],nt="Capture",fs=new RegExp(nt+"$"),ot=(e,t,s)=>{let o=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,r=e&&e.$attrs$||Re,i=t.$attrs$||Re;if(n.updatable)for(let l of ze(Object.keys(r)))l in i||je(o,l,r[l],void 0,s,t.$flags$);for(let l of ze(Object.keys(i)))je(o,l,r[l],i[l],s,t.$flags$)};function ze(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var U,he,I,M=!1,Z=!1,te=!1,b=!1,V=(e,t,s,o)=>{var r;let i=t.$children$[s],l=0,c,a,d;if(n.slotRelocation&&!M&&(te=!0,i.$tag$==="slot"&&(U&&o.classList.add(U+"-s"),i.$flags$|=i.$children$?2:1)),n.isDev&&i.$elm$&&K(`The JSX ${i.$text$!==null?`"${i.$text$}" text`:`"${i.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&i.$text$!==null)c=i.$elm$=g.createTextNode(i.$text$);else if(n.slotRelocation&&i.$flags$&1)c=i.$elm$=n.isDebug||n.hydrateServerSide?hs(i):g.createTextNode("");else{if(n.svg&&!b&&(b=i.$tag$==="svg"),c=i.$elm$=n.svg?g.createElementNS(b?qt:Xt,!M&&n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$):g.createElement(!M&&n.slotRelocation&&i.$flags$&2?"slot-fb":i.$tag$),n.svg&&b&&i.$tag$==="foreignObject"&&(b=!1),n.vdomAttribute&&ot(null,i,b),!!c.getRootNode().querySelector("body")&&n.scoped&&Qt(U)&&c["s-si"]!==U&&c.classList.add(c["s-si"]=U),n.scoped&&be(c,o),i.$children$)for(l=0;l<i.$children$.length;++l)a=V(e,i,l,c),a&&c.appendChild(a);n.svg&&(i.$tag$==="svg"?b=!1:c.tagName==="foreignObject"&&(b=!0))}return c["s-hn"]=I,n.slotRelocation&&i.$flags$&3&&(c["s-sr"]=!0,c["s-cr"]=he,c["s-sn"]=i.$name$||"",c["s-rf"]=(r=i.$attrs$)==null?void 0:r.ref,d=e&&e.$children$&&e.$children$[s],d&&d.$tag$===i.$tag$&&e.$elm$&&(n.experimentalSlotFixes?rt(e.$elm$):H(e.$elm$,!1))),c},rt=e=>{p.$flags$|=1;let t=e.closest(I.toLowerCase());if(t!=null){let s=Array.from(t.childNodes).find(r=>r["s-cr"]),o=Array.from(e.childNodes);for(let r of s?o.reverse():o)r["s-sh"]!=null&&(S(t,r,s!=null?s:null),r["s-sh"]=void 0,te=!0)}p.$flags$&=-2},H=(e,t)=>{p.$flags$|=1;let s=Array.from(e.childNodes);if(e["s-sr"]&&n.experimentalSlotFixes){let o=e;for(;o=o.nextSibling;)o&&o["s-sn"]===e["s-sn"]&&o["s-sh"]===I&&s.push(o)}for(let o=s.length-1;o>=0;o--){let r=s[o];r["s-hn"]!==I&&r["s-ol"]&&(S(lt(r),r,Se(r)),r["s-ol"].remove(),r["s-ol"]=void 0,r["s-sh"]=void 0,te=!0),t&&H(r,t)}p.$flags$&=-2},it=(e,t,s,o,r,i)=>{let l=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,c;for(n.shadowDom&&l.shadowRoot&&l.tagName===I&&(l=l.shadowRoot);r<=i;++r)o[r]&&(c=V(null,s,r,e),c&&(o[r].$elm$=c,S(l,c,n.slotRelocation?Se(t):t)))},at=(e,t,s)=>{for(let o=t;o<=s;++o){let r=e[o];if(r){let i=r.$elm$;dt(r),i&&(n.slotRelocation&&(Z=!0,i["s-ol"]?i["s-ol"].remove():H(i,!0)),i.remove())}}},us=(e,t,s,o,r=!1)=>{let i=0,l=0,c=0,a=0,d=t.length-1,$=t[0],f=t[d],u=o.length-1,h=o[0],m=o[u],x,y;for(;i<=d&&l<=u;)if($==null)$=t[++i];else if(f==null)f=t[--d];else if(h==null)h=o[++l];else if(m==null)m=o[--u];else if(X($,h,r))R($,h,r),$=t[++i],h=o[++l];else if(X(f,m,r))R(f,m,r),f=t[--d],m=o[--u];else if(X($,m,r))n.slotRelocation&&($.$tag$==="slot"||m.$tag$==="slot")&&H($.$elm$.parentNode,!1),R($,m,r),S(e,$.$elm$,f.$elm$.nextSibling),$=t[++i],m=o[--u];else if(X(f,h,r))n.slotRelocation&&($.$tag$==="slot"||m.$tag$==="slot")&&H(f.$elm$.parentNode,!1),R(f,h,r),S(e,f.$elm$,$.$elm$),f=t[--d],h=o[++l];else{if(c=-1,n.vdomKey){for(a=i;a<=d;++a)if(t[a]&&t[a].$key$!==null&&t[a].$key$===h.$key$){c=a;break}}n.vdomKey&&c>=0?(y=t[c],y.$tag$!==h.$tag$?x=V(t&&t[l],s,c,e):(R(y,h,r),t[c]=void 0,x=y.$elm$),h=o[++l]):(x=V(t&&t[l],s,l,e),h=o[++l]),x&&(n.slotRelocation?S(lt($.$elm$),x,Se($.$elm$)):S($.$elm$.parentNode,x,$.$elm$))}i>d?it(e,o[u+1]==null?null:o[u+1].$elm$,s,o,l,u):n.updatable&&l>u&&at(t,i,d)},X=(e,t,s=!1)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?"$nodeId$"in e&&s&&e.$elm$.nodeType!==8?!1:e.$name$===t.$name$:n.vdomKey&&!s?e.$key$===t.$key$:!0:!1,Se=e=>e&&e["s-ol"]||e,lt=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,R=(e,t,s=!1)=>{let o=t.$elm$=e.$elm$,r=e.$children$,i=t.$children$,l=t.$tag$,c=t.$text$,a;!n.vdomText||c===null?(n.svg&&(b=l==="svg"?!0:l==="foreignObject"?!1:b),(n.vdomAttribute||n.reflect)&&(n.slot&&l==="slot"&&!M?n.experimentalSlotFixes&&e.$name$!==t.$name$&&(t.$elm$["s-sn"]=t.$name$||"",rt(t.$elm$.parentElement)):ot(e,t,b)),n.updatable&&r!==null&&i!==null?us(o,r,t,i,s):i!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(o.textContent=""),it(o,null,t,i,0,i.length-1)):!s&&n.updatable&&r!==null&&at(r,0,r.length-1),n.svg&&b&&l==="svg"&&(b=!1)):n.vdomText&&n.slotRelocation&&(a=o["s-cr"])?a.parentNode.textContent=c:n.vdomText&&e.$text$!==c&&(o.data=c)},se=e=>{let t=e.childNodes;for(let s of t)if(s.nodeType===1){if(s["s-sr"]){let o=s["s-sn"];s.hidden=!1;for(let r of t)if(r!==s){if(r["s-hn"]!==s["s-hn"]||o!==""){if(r.nodeType===1&&(o===r.getAttribute("slot")||o===r["s-sn"])||r.nodeType===3&&o===r["s-sn"]){s.hidden=!0;break}}else if(r.nodeType===1||r.nodeType===3&&r.textContent.trim()!==""){s.hidden=!0;break}}}se(s)}},D=[],ct=e=>{let t,s,o;for(let r of e.childNodes){if(r["s-sr"]&&(t=r["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;let i=r["s-sn"];for(o=s.length-1;o>=0;o--)if(t=s[o],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==r["s-hn"]&&(!n.experimentalSlotFixes||!t["s-sh"]||t["s-sh"]!==r["s-hn"]))if(Me(t,i)){let l=D.find(c=>c.$nodeToRelocate$===t);Z=!0,t["s-sn"]=t["s-sn"]||i,l?(l.$nodeToRelocate$["s-sh"]=r["s-hn"],l.$slotRefNode$=r):(t["s-sh"]=r["s-hn"],D.push({$slotRefNode$:r,$nodeToRelocate$:t})),t["s-sr"]&&D.map(c=>{Me(c.$nodeToRelocate$,t["s-sn"])&&(l=D.find(a=>a.$nodeToRelocate$===t),l&&!c.$slotRefNode$&&(c.$slotRefNode$=l.$slotRefNode$))})}else D.some(l=>l.$nodeToRelocate$===t)||D.push({$nodeToRelocate$:t})}r.nodeType===1&&ct(r)}},Me=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",dt=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(dt))},S=(e,t,s)=>{let o=e==null?void 0:e.insertBefore(t,s);return n.scoped&&be(t,e),o},$t=e=>{let t=[];return e&&t.push(...e["s-scs"]||[],e["s-si"],e["s-sc"],...$t(e.parentElement)),t},be=(e,t,s=!1)=>{var o;if(e&&t&&e.nodeType===1){let r=new Set($t(t).filter(Boolean));if(r.size&&((o=e.classList)==null||o.add(...e["s-scs"]=[...r]),e["s-ol"]||s))for(let i of Array.from(e.childNodes))be(i,e,!0)}},Fe=(e,t,s=!1)=>{var o,r,i,l,c;let a=e.$hostElement$,d=e.$cmpMeta$,$=e.$vnode$||B(null,null),f=de(t)?t:Ve(null,null,t);if(I=a.tagName,n.isDev&&Array.isArray(t)&&t.some(de))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${I.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&d.$attrsToReflect$&&(f.$attrs$=f.$attrs$||{},d.$attrsToReflect$.map(([u,h])=>f.$attrs$[h]=a[u])),s&&f.$attrs$)for(let u of Object.keys(f.$attrs$))a.hasAttribute(u)&&!["key","ref","style","class"].includes(u)&&(f.$attrs$[u]=a[u]);if(f.$tag$=null,f.$flags$|=4,e.$vnode$=f,f.$elm$=$.$elm$=n.shadowDom&&a.shadowRoot||a,(n.scoped||n.shadowDom)&&(U=a["s-sc"]),M=_&&(d.$flags$&1)!==0,n.slotRelocation&&(he=a["s-cr"],Z=!1),R($,f,s),n.slotRelocation){if(p.$flags$|=1,te){ct(f.$elm$);for(let u of D){let h=u.$nodeToRelocate$;if(!h["s-ol"]){let m=n.isDebug||n.hydrateServerSide?ps(h):g.createTextNode("");m["s-nr"]=h,S(h.parentNode,h["s-ol"]=m,h)}}for(let u of D){let h=u.$nodeToRelocate$,m=u.$slotRefNode$;if(m){let x=m.parentNode,y=m.nextSibling;if(!n.experimentalSlotFixes||y&&y.nodeType===1){let A=(o=h["s-ol"])==null?void 0:o.previousSibling;for(;A;){let v=(r=A["s-nr"])!=null?r:null;if(v&&v["s-sn"]===h["s-sn"]&&x===v.parentNode){for(v=v.nextSibling;v===h||v!=null&&v["s-sr"];)v=v==null?void 0:v.nextSibling;if(!v||!v["s-nr"]){y=v;break}}A=A.previousSibling}}(!y&&x!==h.parentNode||h.nextSibling!==y)&&h!==y&&(!n.experimentalSlotFixes&&!h["s-hn"]&&h["s-ol"]&&(h["s-hn"]=h["s-ol"].parentNode.nodeName),S(x,h,y),h.nodeType===1&&(h.hidden=(i=h["s-ih"])!=null?i:!1)),h&&typeof m["s-rf"]=="function"&&m["s-rf"](h)}else h.nodeType===1&&(s&&(h["s-ih"]=(l=h.hidden)!=null?l:!1),h.hidden=!0)}}Z&&se(f.$elm$),p.$flags$&=-2,D.length=0}if(n.experimentalScopedSlotChanges&&d.$flags$&2)for(let u of f.$elm$.childNodes)u["s-hn"]!==I&&!u["s-sh"]&&(s&&u["s-ih"]==null&&(u["s-ih"]=(c=u.hidden)!=null?c:!1),u.hidden=!0);he=void 0},hs=e=>g.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${I.toLowerCase()})`),ps=e=>g.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),ft=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},ne=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}ft(e,e.$ancestorComponent$);let s=()=>ms(e,t);return n.taskQueue?Wt(s):s()},ms=(e,t)=>{let s=e.$hostElement$,o=N("scheduleUpdate",e.$cmpMeta$.$tagName$),r=n.lazyLoad?e.$lazyInstance$:s;if(!r)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let i;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([l,c])=>T(r,l,c)),e.$queuedListeners$=void 0)),O(s,"componentWillLoad"),n.cmpWillLoad&&(i=T(r,"componentWillLoad"))):(O(s,"componentWillUpdate"),n.cmpWillUpdate&&(i=T(r,"componentWillUpdate"))),O(s,"componentWillRender"),n.cmpWillRender&&(i=He(i,()=>T(r,"componentWillRender"))),o(),He(i,()=>gs(e,r,t))},He=(e,t)=>vs(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),vs=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",gs=(e,t,s)=>W(void 0,null,function*(){var o;let r=e.$hostElement$,i=N("update",e.$cmpMeta$.$tagName$),l=r["s-rc"];n.style&&s&&ds(e);let c=N("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?yield qe(e,t,r,s):qe(e,t,r,s),n.isDev&&(e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025),n.hydrateServerSide)try{ht(r),s&&(e.$cmpMeta$.$flags$&1?r["s-en"]="":e.$cmpMeta$.$flags$&2&&(r["s-en"]="c"))}catch(a){C(a,r)}if(n.asyncLoading&&l&&(l.map(a=>a()),r["s-rc"]=void 0),c(),i(),n.asyncLoading){let a=(o=r["s-p"])!=null?o:[],d=()=>Xe(e);a.length===0?d():(Promise.all(a).then(d),e.$flags$|=4,a.length=0)}else Xe(e)}),We=null,qe=(e,t,s,o)=>{let r=!!n.allRenderFn,i=!!n.lazyLoad,l=!!n.taskQueue,c=!!n.updatable;try{if(We=t,t=(r||t.render)&&t.render(),c&&l&&(e.$flags$&=-17),(c||i)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(a=>Fe(e,a,o));Fe(e,t,o)}else{let a=s.shadowRoot;e.$cmpMeta$.$flags$&1?a.textContent=t:s.textContent=t}}catch(a){C(a,e.$hostElement$)}return We=null,null};var Xe=e=>{let t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,o=N("postUpdate",t),r=n.lazyLoad?e.$lazyInstance$:s,i=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),T(r,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),O(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),T(r,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),O(s,"componentDidUpdate"),o()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&ut(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),T(r,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),O(s,"componentDidLoad"),o(),n.asyncLoading&&(e.$onReadyResolve$(s),i||ys(t))),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&ee(()=>ne(e,!1)),e.$flags$&=-517)},Cn=e=>{if(n.updatable&&(Ne.isBrowser||Ne.isTesting)){let t=L(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&ne(t,!1),s}return!1},ys=e=>{n.cssAnnotations&&ut(g.documentElement),n.asyncQueue&&(p.$flags$|=2),ee(()=>ye(P,"appload",{detail:{namespace:q}})),n.profile&&performance.measure&&performance.measure(`[Stencil] ${q} initial load (by ${e})`,"st:app:start")},T=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(o){C(o)}},O=(e,t)=>{n.lifecycleDOMEvents&&ye(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:q}})},ut=e=>{var t,s;return n.hydratedClass?e.classList.add((t=n.hydratedSelectorName)!=null?t:"hydrated"):n.hydratedAttribute?e.setAttribute((s=n.hydratedSelectorName)!=null?s:"hydrated",""):void 0},ht=e=>{let t=e.children;if(t!=null)for(let s=0,o=t.length;s<o;s++){let r=t[s];typeof r.connectedCallback=="function"&&r.connectedCallback(),ht(r)}},Ss=(e,t)=>L(e).$instanceValues$.get(t),bs=(e,t,s,o)=>{let r=L(e);if(n.lazyLoad&&!r)throw new Error(`Couldn't find host element for "${o.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);let i=n.lazyLoad?r.$hostElement$:e,l=r.$instanceValues$.get(t),c=r.$flags$,a=n.lazyLoad?r.$lazyInstance$:i;s=as(s,o.$members$[t][0]);let d=Number.isNaN(l)&&Number.isNaN(s),$=s!==l&&!d;if((!n.lazyLoad||!(c&8)||l===void 0)&&$&&(r.$instanceValues$.set(t,s),n.isDev&&(r.$flags$&1024?F(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,i,`
New value`,s,`
Old value`,l):r.$flags$&2048&&F(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,i,`
New value`,s,`
Old value`,l)),!n.lazyLoad||a)){if(n.watchCallback&&o.$watchers$&&c&128){let f=o.$watchers$[t];f&&f.map(u=>{try{a[u](s,l,t)}catch(h){C(h,i)}})}if(n.updatable&&(c&18)===2){if(n.cmpShouldUpdate&&a.componentShouldUpdate&&a.componentShouldUpdate(s,l,t)===!1)return;ne(r,!1)}}},pt=(e,t,s)=>{var o,r;let i=e.prototype;if(n.formAssociated&&t.$flags$&64&&s&1&&zt.forEach(l=>Object.defineProperty(i,l,{value(...c){let a=L(this),d=n.lazyLoad?a.$hostElement$:this,$=n.lazyLoad?a.$lazyInstance$:d;if(!$)a.$onReadyPromise$.then(f=>{let u=f[l];typeof u=="function"&&u.call(f,...c)});else{let f=$[l];typeof f=="function"&&f.call($,...c)}}})),n.member&&t.$members$||n.watchCallback&&(t.$watchers$||e.watchers)){n.watchCallback&&e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);let l=Object.entries((o=t.$members$)!=null?o:{});if(l.map(([c,[a]])=>{(n.prop||n.state)&&(a&31||(!n.lazyLoad||s&2)&&a&32)?Object.defineProperty(i,c,{get(){return Ss(this,c)},set(d){if(n.isDev){let $=L(this);(s&1)===0&&($&&$.$flags$&8)===0&&(a&31)!==0&&(a&1024)===0&&F(`@Prop() "${c}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}bs(this,c,d,t)},configurable:!0,enumerable:!0}):n.lazyLoad&&n.method&&s&1&&a&64&&Object.defineProperty(i,c,{value(...d){var $;let f=L(this);return($=f==null?void 0:f.$onInstancePromise$)==null?void 0:$.then(()=>{var u;return(u=f.$lazyInstance$)==null?void 0:u[c](...d)})}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){let c=new Map;i.attributeChangedCallback=function(a,d,$){p.jmp(()=>{var f;let u=c.get(a);if(this.hasOwnProperty(u))$=this[u],delete this[u];else{if(i.hasOwnProperty(u)&&typeof this[u]=="number"&&this[u]==$)return;if(u==null){let h=L(this),m=h==null?void 0:h.$flags$;if(m&&!(m&8)&&m&128&&$!==d){let x=n.lazyLoad?h.$hostElement$:this,y=n.lazyLoad?h.$lazyInstance$:x,A=(f=t.$watchers$)==null?void 0:f[a];A==null||A.forEach(v=>{y[v]!=null&&y[v].call(y,$,d,a)})}return}}this[u]=$===null&&typeof this[u]=="boolean"?!1:$})},e.observedAttributes=Array.from(new Set([...Object.keys((r=t.$watchers$)!=null?r:{}),...l.filter(([a,d])=>d[0]&15).map(([a,d])=>{var $;let f=d[1]||a;return c.set(f,a),n.reflect&&d[0]&512&&(($=t.$attrsToReflect$)==null||$.push([a,f])),f})]))}}return e},Qe=(e,t,s,o)=>W(void 0,null,function*(){let r;if((t.$flags$&32)===0){t.$flags$|=32;let c=s.$lazyBundleId$;if((n.lazyLoad||n.hydrateClientSide)&&c){let a=Ut(s,t,o);if(a&&"then"in a){let $=es(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);r=yield a,$()}else r=a;if(!r)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!r.isProxied&&(n.watchCallback&&(s.$watchers$=r.watchers),pt(r,s,2),r.isProxied=!0);let d=N("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new r(t)}catch($){C($)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),d(),pe(t.$lazyInstance$)}else{r=e.constructor;let a=e.localName;customElements.whenDefined(a).then(()=>t.$flags$|=128)}if(n.style&&r&&r.style){let a;typeof r.style=="string"?a=r.style:n.mode&&typeof r.style!="string"&&(t.$modeName$=is(e),t.$modeName$&&(a=r.style[t.$modeName$]),n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));let d=st(s,t.$modeName$);if(!Y.has(d)){let $=N("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(a=yield import("./chunk-7HI2BJAU.js").then(f=>f.scopeCss(a,d))),cs(d,a,!!(s.$flags$&1)),$()}}}let i=t.$ancestorComponent$,l=()=>ne(t,!0);n.asyncLoading&&i&&i["s-rc"]?i["s-rc"].push(l):l()}),pe=e=>{n.lazyLoad&&n.connectedCallback&&T(e,"connectedCallback")},Ls=e=>{if((p.$flags$&1)===0){let t=L(e),s=t.$cmpMeta$,o=N("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&ve(e,t,s.$listeners$,!0),t.$flags$&1)ve(e,t,s.$listeners$,!1),t!=null&&t.$lazyInstance$?pe(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>pe(t.$lazyInstance$));else{t.$flags$|=1;let r;if(n.hydrateClientSide&&(r=e.getAttribute(le),r)){if(n.shadowDom&&_&&s.$flags$&1){let i=n.mode?ue(e.shadowRoot,s,e.getAttribute("s-mode")):ue(e.shadowRoot,s);e.classList.remove(i+"-h",i+"-s")}rs(e,s.$tagName$,r,t)}if(n.slotRelocation&&!r&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&xs(e),n.asyncLoading){let i=e;for(;i=i.parentNode||i.host;)if(n.hydrateClientSide&&i.nodeType===1&&i.hasAttribute("s-id")&&i["s-p"]||i["s-p"]){ft(t,t.$ancestorComponent$=i);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([i,[l]])=>{if(l&31&&e.hasOwnProperty(i)){let c=e[i];delete e[i],e[i]=c}}),n.initializeNextTick?ee(()=>Qe(e,t,s)):Qe(e,t,s)}o()}},xs=e=>{let t=e["s-cr"]=g.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,S(e,t,e.firstChild)},ae=e=>{n.lazyLoad&&n.disconnectedCallback&&T(e,"disconnectedCallback"),n.cmpDidUnload&&T(e,"componentDidUnload")},Ts=e=>W(void 0,null,function*(){if((p.$flags$&1)===0){let t=L(e);n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0),n.lazyLoad?t!=null&&t.$lazyInstance$?ae(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ae(t.$lazyInstance$)):ae(e)}}),Ds=(e,t)=>{mt(e),vt(e),Cs(e),Ns(e),Es(e),ks(e),As(e),gt(e),yt(e,t),Is(e)},mt=e=>{let t=e.cloneNode;e.cloneNode=function(s){let o=this,r=n.shadowDom?o.shadowRoot&&_:!1,i=t.call(o,r?s:!1);if(n.slot&&!r&&s){let l=0,c,a,d=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si","s-rf","s-scs"];for(;l<o.childNodes.length;l++)c=o.childNodes[l]["s-nr"],a=d.every($=>!o.childNodes[l][$]),c&&(n.appendChildSlotFix&&i.__appendChild?i.__appendChild(c.cloneNode(!0)):i.appendChild(c.cloneNode(!0))),a&&i.appendChild(o.childNodes[l].cloneNode(!0))}return i}},vt=e=>{e.__appendChild=e.appendChild,e.appendChild=function(t){let s=t["s-sn"]=St(t),o=j(this.childNodes,s,this.tagName);if(o){let r=Le(o,s),i=r[r.length-1],l=S(i.parentNode,t,i.nextSibling);return se(this),l}return this.__appendChild(t)}},Is=e=>{e.__removeChild=e.removeChild,e.removeChild=function(t){if(t&&typeof t["s-sn"]<"u"){let s=j(this.childNodes,t["s-sn"],this.tagName);if(s){let r=Le(s,t["s-sn"]).find(i=>i===t);if(r){r.remove(),se(this);return}}}return this.__removeChild(t)}},Ns=e=>{let t=e.prepend;e.prepend=function(...s){s.forEach(o=>{typeof o=="string"&&(o=this.ownerDocument.createTextNode(o));let r=o["s-sn"]=St(o),i=j(this.childNodes,r,this.tagName);if(i){let l=document.createTextNode("");l["s-nr"]=o,i["s-cr"].parentNode.__appendChild(l),o["s-ol"]=l;let a=Le(i,r)[0];return S(a.parentNode,o,a.nextSibling)}return o.nodeType===1&&o.getAttribute("slot")&&(o.hidden=!0),t.call(this,o)})}},Cs=e=>{e.append=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s)),this.appendChild(s)})}},ks=e=>{let t=e.insertAdjacentHTML;e.insertAdjacentHTML=function(s,o){if(s!=="afterbegin"&&s!=="beforeend")return t.call(this,s,o);let r=this.ownerDocument.createElement("_"),i;if(r.innerHTML=o,s==="afterbegin")for(;i=r.firstChild;)this.prepend(i);else if(s==="beforeend")for(;i=r.firstChild;)this.append(i)}},As=e=>{e.insertAdjacentText=function(t,s){this.insertAdjacentHTML(t,s)}},Es=e=>{let t=e.insertAdjacentElement;e.insertAdjacentElement=function(s,o){return s!=="afterbegin"&&s!=="beforeend"?t.call(this,s,o):s==="afterbegin"?(this.prepend(o),o):(s==="beforeend"&&this.append(o),o)}},gt=e=>{let t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),n.experimentalScopedSlotChanges?Object.defineProperty(e,"textContent",{get(){return" "+me(this.childNodes).map(r=>{var i,l;let c=[],a=r.nextSibling;for(;a&&a["s-sn"]===r["s-sn"];)(a.nodeType===3||a.nodeType===1)&&c.push((l=(i=a.textContent)==null?void 0:i.trim())!=null?l:""),a=a.nextSibling;return c.filter(d=>d!=="").join(" ")}).filter(r=>r!=="").join(" ")+" "},set(s){me(this.childNodes).forEach(r=>{let i=r.nextSibling;for(;i&&i["s-sn"]===r["s-sn"];){let l=i;i=i.nextSibling,l.remove()}if(r["s-sn"]===""){let l=this.ownerDocument.createTextNode(s);l["s-sn"]="",S(r.parentElement,l,r.nextSibling)}else r.remove()})}}):Object.defineProperty(e,"textContent",{get(){var s;let o=j(this.childNodes,"",this.tagName);return((s=o==null?void 0:o.nextSibling)==null?void 0:s.nodeType)===3?o.nextSibling.textContent:o?o.textContent:this.__textContent},set(s){var o;let r=j(this.childNodes,"",this.tagName);if(((o=r==null?void 0:r.nextSibling)==null?void 0:o.nodeType)===3)r.nextSibling.textContent=s;else if(r)r.textContent=s;else{this.__textContent=s;let i=this["s-cr"];i&&S(this,i,this.firstChild)}}})},yt=(e,t)=>{class s extends Array{item(r){return this[r]}}if(t.$flags$&8){let o=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map(r=>r.nodeType===1)}}),Object.defineProperty(e,"childElementCount",{get(){return e.children.length}}),Object.defineProperty(e,"childNodes",{get(){let r=o.call(this);if((p.$flags$&1)===0&&L(this).$flags$&2){let i=new s;for(let l=0;l<r.length;l++){let c=r[l]["s-nr"];c&&i.push(c)}return i}return s.from(r)}})}},me=e=>{let t=[];for(let s of Array.from(e))s["s-sr"]&&t.push(s),t.push(...me(s.childNodes));return t},St=e=>e["s-sn"]||e.nodeType===1&&e.getAttribute("slot")||"",j=(e,t,s)=>{let o=0,r;for(;o<e.length;o++)if(r=e[o],r["s-sr"]&&r["s-sn"]===t&&r["s-hn"]===s||(r=j(r.childNodes,t,s),r))return r;return null},Le=(e,t)=>{let s=[e];for(;(e=e.nextSibling)&&e["s-sn"]===t;)s.push(e);return s};var En=(e,t)=>{let s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!_&&s.$flags$&1&&(s.$flags$|=8),n.experimentalSlotFixes?n.scoped&&s.$flags$&2&&Ds(e.prototype,s):(n.slotChildNodesFix&&yt(e.prototype,s),n.cloneNodeFix&&mt(e.prototype),n.appendChildSlotFix&&vt(e.prototype),n.scopedSlotTextContentFix&&s.$flags$&2&&gt(e.prototype));let o=e.prototype.connectedCallback,r=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){_t(this,s)},connectedCallback(){let i=L(this);ve(this,i,s.$listeners$,!1),Ls(this),n.connectedCallback&&o&&o.call(this)},disconnectedCallback(){Ts(this),n.disconnectedCallback&&r&&r.call(this)},__attachShadow(){if(_){if(!this.shadowRoot)n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"});else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}else this.shadowRoot=this}}),e.is=s.$tagName$,pt(e,s,3)};var ve=(e,t,s,o)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(o?s=s.filter(([r])=>r&32):s=s.filter(([r])=>!(r&32))),s.map(([r,i,l])=>{let c=n.hostListenerTarget?ws(e,r):e,a=_s(t,l),d=Us(r);p.ael(c,i,a,d),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>p.rel(c,i,a,d))}))},_s=(e,t)=>s=>{var o;try{n.lazyLoad?e.$flags$&256?(o=e.$lazyInstance$)==null||o[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(r){C(r)}},ws=(e,t)=>n.hostListenerTargetDocument&&t&4?g:n.hostListenerTargetWindow&&t&8?P:n.hostListenerTargetBody&&t&16?g.body:n.hostListenerTargetParent&&t&32&&e.parentElement?e.parentElement:e,Us=e=>Mt?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;var xe=class{constructor(){this.m=new Map}reset(t){this.m=new Map(Object.entries(t))}get(t,s){let o=this.m.get(t);return o!==void 0?o:s}getBoolean(t,s=!1){let o=this.m.get(t);return o===void 0?s:typeof o=="string"?o==="true":!!o}getNumber(t,s){let o=parseFloat(this.m.get(t));return isNaN(o)?s!==void 0?s:NaN:o}set(t,s){this.m.set(t,s)}},k=new xe,Rs=e=>{try{let t=e.sessionStorage.getItem(xt);return t!==null?JSON.parse(t):{}}catch{return{}}},Os=(e,t)=>{try{e.sessionStorage.setItem(xt,JSON.stringify(t))}catch{return}},Bs=e=>{let t={};return e.location.search.slice(1).split("&").map(s=>s.split("=")).map(([s,o])=>{try{return[decodeURIComponent(s),decodeURIComponent(o)]}catch{return["",""]}}).filter(([s])=>js(s,bt)).map(([s,o])=>[s.slice(bt.length),o]).forEach(([s,o])=>{t[s]=o}),t},js=(e,t)=>e.substr(0,t.length)===t,bt="ionic:",xt="ionic-persist-config",Ps=e=>Tt(e),zs=(e,t)=>(typeof e=="string"&&(t=e,e=void 0),Ps(e).includes(t)),Tt=(e=window)=>{if(typeof e>"u")return[];e.Ionic=e.Ionic||{};let t=e.Ionic.platforms;return t==null&&(t=e.Ionic.platforms=Ms(e),t.forEach(s=>e.document.documentElement.classList.add(`plt-${s}`))),t},Ms=e=>{let t=k.get("platform");return Object.keys(Lt).filter(s=>{let o=t==null?void 0:t[s];return typeof o=="function"?o(e):Lt[s](e)})},Fs=e=>oe(e)&&!It(e),Te=e=>!!(w(e,/iPad/i)||w(e,/Macintosh/i)&&oe(e)),Hs=e=>w(e,/iPhone/i),Ws=e=>w(e,/iPhone|iPod/i)||Te(e),Dt=e=>w(e,/android|sink/i),qs=e=>Dt(e)&&!w(e,/mobile/i),Xs=e=>{let t=e.innerWidth,s=e.innerHeight,o=Math.min(t,s),r=Math.max(t,s);return o>390&&o<520&&r>620&&r<800},Qs=e=>{let t=e.innerWidth,s=e.innerHeight,o=Math.min(t,s),r=Math.max(t,s);return Te(e)||qs(e)||o>460&&o<820&&r>780&&r<1400},oe=e=>Js(e,"(any-pointer:coarse)"),Ks=e=>!oe(e),It=e=>Nt(e)||Ct(e),Nt=e=>!!(e.cordova||e.phonegap||e.PhoneGap),Ct=e=>{let t=e.Capacitor;return!!(t!=null&&t.isNative||t!=null&&t.isNativePlatform&&t.isNativePlatform())},Ys=e=>w(e,/electron/i),Gs=e=>{var t;return!!(!((t=e.matchMedia)===null||t===void 0)&&t.call(e,"(display-mode: standalone)").matches||e.navigator.standalone)},w=(e,t)=>t.test(e.navigator.userAgent),Js=(e,t)=>{var s;return(s=e.matchMedia)===null||s===void 0?void 0:s.call(e,t).matches},Lt={ipad:Te,iphone:Hs,ios:Ws,android:Dt,phablet:Xs,tablet:Qs,cordova:Nt,capacitor:Ct,electron:Ys,pwa:Gs,mobile:oe,mobileweb:Fs,desktop:Ks,hybrid:It},z,jn=e=>e&&tt(e)||z,Pn=(e={})=>{if(typeof window>"u")return;let t=window.document,s=window,o=s.Ionic=s.Ionic||{},r=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},Rs(s)),{persistConfig:!1}),o.config),Bs(s)),e);k.reset(r),k.getBoolean("persistConfig")&&Os(s,r),Tt(s),o.config=k,o.mode=z=k.get("mode",t.documentElement.getAttribute("mode")||(zs(s,"ios")?"ios":"md")),k.set("mode",z),t.documentElement.setAttribute("mode",z),t.documentElement.classList.add(z),k.getBoolean("_testing")&&k.set("animated",!1);let i=c=>{var a;return(a=c.tagName)===null||a===void 0?void 0:a.startsWith("ION-")},l=c=>["ios","md"].includes(c);et(c=>{for(;c;){let a=c.mode||c.getAttribute("mode");if(a){if(l(a))return a;i(c)&&console.warn('Invalid ionic mode: "'+a+'", expected: "ios" or "md"')}c=c.parentElement}return z})};export{Ne as a,ln as b,cn as c,Wt as d,dn as e,Ve as f,ts as g,xn as h,Cn as i,En as j,k,Ps as l,zs as m,jn as n,Pn as o};
